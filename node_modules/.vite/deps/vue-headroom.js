import {
  __commonJS
} from "./chunk-76J2PTFD.js";

// node_modules/vue-headroom/dist/vue-headroom-umd.js
var require_vue_headroom_umd = __commonJS({
  "node_modules/vue-headroom/dist/vue-headroom-umd.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.vueHeadroom = factory());
    })(exports, function() {
      "use strict";
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function createCommonjsModule(fn, module2) {
        return module2 = { exports: {} }, fn(module2, module2.exports), module2.exports;
      }
      var performanceNow = createCommonjsModule(function(module2) {
        (function() {
          var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
          if (typeof performance !== "undefined" && performance !== null && performance.now) {
            module2.exports = function() {
              return performance.now();
            };
          } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
            module2.exports = function() {
              return (getNanoSeconds() - nodeLoadTime) / 1e6;
            };
            hrtime = process.hrtime;
            getNanoSeconds = function() {
              var hr;
              hr = hrtime();
              return hr[0] * 1e9 + hr[1];
            };
            moduleLoadTime = getNanoSeconds();
            upTime = process.uptime() * 1e9;
            nodeLoadTime = moduleLoadTime - upTime;
          } else if (Date.now) {
            module2.exports = function() {
              return Date.now() - loadTime;
            };
            loadTime = Date.now();
          } else {
            module2.exports = function() {
              return (/* @__PURE__ */ new Date()).getTime() - loadTime;
            };
            loadTime = (/* @__PURE__ */ new Date()).getTime();
          }
        }).call(commonjsGlobal);
      });
      var root = typeof window === "undefined" ? commonjsGlobal : window, vendors = ["moz", "webkit"], suffix = "AnimationFrame", raf = root["request" + suffix], caf = root["cancel" + suffix] || root["cancelRequest" + suffix];
      for (var i = 0; !raf && i < vendors.length; i++) {
        raf = root[vendors[i] + "Request" + suffix];
        caf = root[vendors[i] + "Cancel" + suffix] || root[vendors[i] + "CancelRequest" + suffix];
      }
      if (!raf || !caf) {
        var last = 0, id = 0, queue = [], frameDuration = 1e3 / 60;
        raf = function(callback) {
          if (queue.length === 0) {
            var _now = performanceNow(), next = Math.max(0, frameDuration - (_now - last));
            last = next + _now;
            setTimeout(function() {
              var cp = queue.slice(0);
              queue.length = 0;
              for (var i2 = 0; i2 < cp.length; i2++) {
                if (!cp[i2].cancelled) {
                  try {
                    cp[i2].callback(last);
                  } catch (e) {
                    setTimeout(function() {
                      throw e;
                    }, 0);
                  }
                }
              }
            }, Math.round(next));
          }
          queue.push({
            handle: ++id,
            callback,
            cancelled: false
          });
          return id;
        };
        caf = function(handle) {
          for (var i2 = 0; i2 < queue.length; i2++) {
            if (queue[i2].handle === handle) {
              queue[i2].cancelled = true;
            }
          }
        };
      }
      var raf_1 = function(fn) {
        return raf.call(root, fn);
      };
      var cancel = function() {
        caf.apply(root, arguments);
      };
      var polyfill = function(object) {
        if (!object) {
          object = root;
        }
        object.requestAnimationFrame = raf;
        object.cancelAnimationFrame = caf;
      };
      raf_1.cancel = cancel;
      raf_1.polyfill = polyfill;
      function checkActions(states) {
        var direction = states.currentScrollY >= states.lastScrollY ? "down" : "up";
        var distanceScrolled = Math.abs(states.currentScrollY - states.lastScrollY);
        var isInit = states.lastScrollY === void 0;
        var action;
        if (states.currentScrollY > states.height + states.offset && states.state === "unfixed" && isInit) {
          action = "pin";
        } else if (states.currentScrollY <= states.offset && states.state !== "unfixed") {
          action = "unfix";
        } else if (states.currentScrollY <= states.height && direction === "down" && states.state === "unfixed") {
          action = "none";
        } else if (states.currentScrollY > states.height + states.offset && direction === "down" && states.state === "unfixed" && !isInit) {
          action = "unpin-snap";
        } else if (direction === "down" && ["pinned", "unfixed"].indexOf(states.state) >= 0 && states.currentScrollY > states.height + states.offset && distanceScrolled > states.downTolerance) {
          action = "unpin";
        } else if (direction === "up" && distanceScrolled > states.upTolerance && ["pinned", "unfixed"].indexOf(states.state) < 0) {
          action = "pin";
        } else if (direction === "up" && states.currentScrollY <= states.height && ["pinned", "unfixed"].indexOf(states.state) < 0) {
          action = "pin";
        } else {
          action = "none";
        }
        return action;
      }
      function supports3d() {
        var div = document.createElement("div");
        var ret = false;
        var properties = ["perspectiveProperty", "WebkitPerspective"];
        for (var i2 = properties.length - 1; i2 >= 0; i2--) {
          ret = ret ? ret : div.style[properties[i2]] !== void 0;
        }
        if (ret) {
          var st = document.createElement("style");
          st.textContent = "#modernizr{width:0;height:0} @media (transform-3d),(-webkit-transform-3d){#modernizr{width:7px;height:18px;margin:0;padding:0;border:0}}";
          document.getElementsByTagName("head")[0].appendChild(st);
          div.id = "modernizr";
          document.body.appendChild(div);
          ret = div.offsetWidth === 7 && div.offsetHeight === 18;
          st.parentNode.removeChild(st);
          div.parentNode.removeChild(div);
        }
        return ret;
      }
      var defaultCls = {
        pinned: "headroom--pinned",
        unpinned: "headroom--unpinned",
        unfixed: "headroom--unfixed",
        top: "headroom--top",
        notTop: "headroom--not-top",
        bottom: "headroom--bottom",
        notBottom: "headroom--not-bottom",
        initial: "headroom"
      };
      var script = {
        name: "vueHeadroom",
        data: function data() {
          return {
            isTop: false,
            isNotTop: false,
            isBottom: false,
            isNotBottom: false,
            isPinned: false,
            isUnpinned: false,
            currentScrollY: 0,
            lastScrollY: void 0,
            state: "unfixed",
            translate: 0,
            height: "",
            animation: true,
            isSupport3d: false
          };
        },
        props: {
          scroller: {
            type: Function,
            "default": function _default() {
              return window;
            }
          },
          disabled: {
            type: Boolean,
            "default": false
          },
          upTolerance: {
            type: Number,
            "default": 5
          },
          downTolerance: {
            type: Number,
            "default": 0
          },
          speed: {
            type: Number,
            "default": 250
          },
          easing: {
            type: String,
            "default": "ease-in-out"
          },
          zIndex: {
            type: Number,
            "default": 9999
          },
          offset: {
            type: Number,
            "default": 0
          },
          classes: {
            type: Object,
            "default": function _default() {
              return defaultCls;
            }
          },
          footroom: {
            type: Boolean,
            "default": false
          }
        },
        watch: {
          disabled: function disabled(newVal) {
            if (newVal) {
              this.scroller().removeEventListener("scroll", this._handleScroll);
            } else {
              this.scroller().addEventListener("scroll", this._handleScroll);
            }
          }
        },
        mounted: function mounted() {
          this.isSupport3d = supports3d();
          this._setHeightOffset();
          if (!this.disabled) {
            this.scroller().addEventListener("scroll", this._handleScroll);
          }
          this._handleScroll();
        },
        updated: function updated() {
          this.$nextTick(function() {
            this._setHeightOffset();
          });
        },
        beforeDestroy: function beforeDestroy() {
          this.scroller().removeEventListener("scroll", this._handleScroll);
        },
        computed: {
          style: function style() {
            var styles = {
              "position": this.disabled || this.state === "unfixed" ? "relative" : "fixed",
              "top": "0",
              "left": "0",
              "right": "0",
              "z-index": this.zIndex
            };
            if (this.footroom) {
              styles = Object.assign({}, styles, {
                "top": "unset",
                "bottom": "0"
              });
            }
            if (!this.$isServer) {
              styles.transform = this.isSupport3d && !this.$isServer ? "translate3d(0, ".concat(this.translate, ", 0)") : "translateY(".concat(this.translate, ")");
              if (this.animation) {
                styles.transition = "all ".concat(this.speed, "ms ").concat(this.easing);
              }
            }
            return styles;
          },
          clsOpts: function clsOpts() {
            return Object.assign({}, defaultCls, this.classes);
          },
          cls: function cls() {
            var _ref;
            var cls2 = this.clsOpts;
            return this.disabled ? {} : (_ref = {}, _defineProperty(_ref, cls2.top, this.isTop), _defineProperty(_ref, cls2.notTop, this.isNotTop), _defineProperty(_ref, cls2.bottom, this.isBottom), _defineProperty(_ref, cls2.notBottom, this.isNotBottom), _defineProperty(_ref, cls2.pinned, this.isPinned), _defineProperty(_ref, cls2.unpinned, this.isUnpinned), _defineProperty(_ref, cls2.initial, true), _ref);
          }
        },
        methods: {
          _getViewportHeight: function _getViewportHeight() {
            return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
          },
          _getElementPhysicalHeight: function _getElementPhysicalHeight(elm) {
            return Math.max(elm.offsetHeight, elm.clientHeight);
          },
          _getDocumentHeight: function _getDocumentHeight() {
            var body = document.body;
            var documentElement = document.documentElement;
            return Math.max(body.scrollHeight, documentElement.scrollHeight, body.offsetHeight, documentElement.offsetHeight, body.clientHeight, documentElement.clientHeight);
          },
          _getElementHeight: function _getElementHeight(elm) {
            return Math.max(elm.scrollHeight, elm.offsetHeight, elm.clientHeight);
          },
          _getScrollerPhysicalHeight: function _getScrollerPhysicalHeight() {
            var parent = this.scroller();
            return parent === window || parent === document.body ? this._getViewportHeight() : this._getElementPhysicalHeight(parent);
          },
          _getScrollerHeight: function _getScrollerHeight() {
            var parent = this.scroller();
            return parent === window || parent === document.body ? this._getDocumentHeight() : this._getElementHeight(parent);
          },
          _isOutOfBound: function _isOutOfBound(currentScrollY) {
            var pastTop = currentScrollY < 0;
            var scrollerPhysicalHeight = this._getScrollerPhysicalHeight();
            var scrollerHeight = this._getScrollerHeight();
            var pastBottom = currentScrollY + scrollerPhysicalHeight > scrollerHeight;
            return pastTop || pastBottom;
          },
          _handleScroll: function _handleScroll() {
            raf_1(this.update);
          },
          _setHeightOffset: function _setHeightOffset() {
            this.height = this.$slots["default"] ? this.$slots["default"][0].elm && this.$slots["default"][0].elm.offsetHeight : "";
          },
          _getScrollY: function _getScrollY() {
            var top;
            if (this.scroller().pageYOffset !== void 0) {
              top = this.scroller().pageYOffset;
            } else if (this.scroller().scrollTop !== void 0) {
              top = this.scroller().scrollTop;
            } else {
              top = (document.documentElement || document.body.parentNode || document.body).scrollTop;
            }
            return top;
          },
          update: function update() {
            this.currentScrollY = this._getScrollY();
            if (this._isOutOfBound(this.currentScrollY)) {
              return;
            }
            if (this.currentScrollY <= this.offset) {
              this.top();
            } else {
              this.notTop();
            }
            if (this.currentScrollY + this._getViewportHeight() >= this._getScrollerHeight()) {
              this.bottom();
            } else {
              this.notBottom();
            }
            var action = checkActions(this);
            if (action === "pin") {
              this.pin();
            } else if (action === "unpin-snap") {
              this.unpinSnap();
            } else if (action === "unpin") {
              this.unpin();
            } else if (action === "unfix") {
              this.unfix();
            }
            this.lastScrollY = this.currentScrollY;
          },
          top: function top() {
            this.isTop = true;
            this.isNotTop = false;
            this.$emit("top");
          },
          notTop: function notTop() {
            this.isTop = false;
            this.isNotTop = true;
            this.$emit("not-top");
          },
          bottom: function bottom() {
            this.isBottom = true;
            this.isNotBottom = false;
            this.$emit("bottom");
          },
          notBottom: function notBottom() {
            this.isNotBottom = true;
            this.isBottom = false;
            this.$emit("not-bottom");
          },
          pin: function pin() {
            var _this = this;
            this.isPinned = true;
            this.isUnpinned = false;
            this.animation = true;
            this.$emit("pin");
            this.translate = 0;
            this.$nextTick(function() {
              _this.state = "pinned";
            });
          },
          unpin: function unpin() {
            var _this2 = this;
            this.isUnpinned = true;
            this.isPinned = false;
            this.animation = true;
            this.$emit("unpin");
            this.translate = this.footroom ? "100%" : "-100%";
            this.$nextTick(function() {
              _this2.state = "unpinned";
            });
          },
          unpinSnap: function unpinSnap() {
            var _this3 = this;
            this.isUnpinned = true;
            this.isPinned = false;
            this.animation = false;
            this.$emit("unpin");
            this.translate = this.footroom ? "100%" : "-100%";
            this.$nextTick(function() {
              _this3.state = "unpinned";
            });
          },
          unfix: function unfix() {
            var _this4 = this;
            this.translate = 0;
            this.animation = false;
            this.$emit("unfix");
            this.$nextTick(function() {
              _this4.state = "unfixed";
            });
          }
        }
      };
      function normalizeComponent(template, style, script2, scopeId, isFunctionalTemplate, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
        if (typeof shadowMode !== "boolean") {
          createInjectorSSR = createInjector;
          createInjector = shadowMode;
          shadowMode = false;
        }
        var options = typeof script2 === "function" ? script2.options : script2;
        if (template && template.render) {
          options.render = template.render;
          options.staticRenderFns = template.staticRenderFns;
          options._compiled = true;
          if (isFunctionalTemplate) {
            options.functional = true;
          }
        }
        if (scopeId) {
          options._scopeId = scopeId;
        }
        var hook;
        if (moduleIdentifier) {
          hook = function hook2(context) {
            context = context || // cached call
            this.$vnode && this.$vnode.ssrContext || // stateful
            this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
            if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
              context = __VUE_SSR_CONTEXT__;
            }
            if (style) {
              style.call(this, createInjectorSSR(context));
            }
            if (context && context._registeredComponents) {
              context._registeredComponents.add(moduleIdentifier);
            }
          };
          options._ssrRegister = hook;
        } else if (style) {
          hook = shadowMode ? function() {
            style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
          } : function(context) {
            style.call(this, createInjector(context));
          };
        }
        if (hook) {
          if (options.functional) {
            var originalRender = options.render;
            options.render = function renderWithStyleInjection(h, context) {
              hook.call(context);
              return originalRender(h, context);
            };
          } else {
            var existing = options.beforeCreate;
            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
          }
        }
        return script2;
      }
      var normalizeComponent_1 = normalizeComponent;
      var __vue_script__ = script;
      var __vue_render__ = function __vue_render__2() {
        var _vm = this;
        var _h = _vm.$createElement;
        var _c = _vm._self._c || _h;
        return _c("div", {
          style: {
            height: _vm.height + "px"
          }
        }, [_c("div", {
          "class": _vm.cls,
          style: _vm.style
        }, [_vm._t("default")], 2)]);
      };
      var __vue_staticRenderFns__ = [];
      var __vue_inject_styles__ = void 0;
      var __vue_scope_id__ = void 0;
      var __vue_module_identifier__ = void 0;
      var __vue_is_functional_template__ = false;
      var headroom = normalizeComponent_1({
        render: __vue_render__,
        staticRenderFns: __vue_staticRenderFns__
      }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, void 0, void 0);
      var install = function install2(Vue) {
        if (install2.installed) {
          return;
        }
        Vue.component(headroom.name, headroom);
      };
      if (typeof window !== "undefined" && window.Vue) {
        install(window.Vue);
      }
      var index = {
        headroom,
        install
      };
      return index;
    });
  }
});
export default require_vue_headroom_umd();
/*! Bundled license information:

vue-headroom/dist/vue-headroom-umd.js:
  (*!
   * vue-headroom v0.10.1
   * (c) dalphyx <wjcbmk@gmail.com>
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=vue-headroom.js.map
